# Глава 1: Введение в Go и настройка проекта

В этой главе мы установим Go, познакомимся с основами языка и создадим первую программу. Каждая конструкция будет объяснена простым языком.

---

## 1. Установка Go

**Что такое Go:**  
Go (или Golang) — это язык программирования, созданный в Google. Он простой, быстрый и отлично подходит для создания серверных приложений.

**Что делаем:**  
Скачиваем и устанавливаем Go на компьютер.

**Шаги:**
1. Перейдите на сайт [https://go.dev/dl/](https://go.dev/dl/)
2. Скачайте установщик для вашей операционной системы
3. Запустите установщик и следуйте инструкциям
4. После установки откройте терминал и проверьте версию:

```bash
go version
```

**Результат:**  
Вы увидите что-то вроде `go version go1.21.0 windows/amd64`. Это значит, что Go установлен правильно.

---

## 2. Создаём папку проекта

**Что делаем:**  
Создаём папку для нашего проекта и инициализируем Go-модуль.

**Шаги:**
```bash
# Создаём папку проекта
mkdir tempmail
cd tempmail

# Инициализируем Go-модуль
go mod init tempmail
```

**Что такое `go mod init`:**  
Эта команда создаёт файл `go.mod`, который хранит информацию о проекте и его зависимостях (внешних библиотеках). Это как `package.json` в JavaScript или `requirements.txt` в Python.

**Результат:**  
В папке появится файл `go.mod` с содержимым:
```
module tempmail

go 1.21
```

---

## 3. Первая программа на Go

**Что делаем:**  
Создаём простейшую программу, чтобы понять основы синтаксиса Go.

**Создайте файл `main.go`:**
```go
package main

import "fmt"

func main() {
    fmt.Println("Привет, TempMail!")
}
```

**Разбор по строкам:**

- `package main` — объявляем, что этот файл принадлежит пакету `main`. В Go каждый файл должен принадлежать какому-то пакету. Пакет `main` — особый, с него начинается выполнение программы.

- `import "fmt"` — подключаем пакет `fmt` (сокращение от "format"). Этот пакет содержит функции для вывода текста на экран.

- `func main()` — объявляем функцию с именем `main`. Ключевое слово `func` означает "функция". Функция `main` — точка входа в программу, она запускается первой.

- `{` и `}` — фигурные скобки обозначают начало и конец тела функции. Всё, что внутри них, выполняется при вызове функции.

- `fmt.Println("Привет, TempMail!")` — вызываем функцию `Println` из пакета `fmt`. Она выводит текст на экран и переходит на новую строку. Текст в кавычках — это строка (string).

**Запускаем программу:**
```bash
go run main.go
```

**Что такое `go run`:**  
Эта команда компилирует (превращает код в программу) и сразу запускает файл. Удобно для разработки.

**Результат:**  
На экране появится: `Привет, TempMail!`

---

## 4. Переменные в Go

**Что такое переменная:**  
Переменная — это именованное место в памяти, где хранится какое-то значение. Как коробка с надписью, в которую можно положить что-то.

**Создаём переменные:**
```go
package main

import "fmt"

func main() {
    // Способ 1: полное объявление
    var name string = "TempMail"
    
    // Способ 2: короткое объявление (Go сам определит тип)
    port := 8080
    
    // Способ 3: объявление без значения (будет значение по умолчанию)
    var isActive bool  // по умолчанию false
    
    fmt.Println("Сервис:", name)
    fmt.Println("Порт:", port)
    fmt.Println("Активен:", isActive)
}
```

**Разбор:**

- `var name string = "TempMail"` — создаём переменную `name` типа `string` (строка) со значением "TempMail".
  - `var` — ключевое слово для объявления переменной
  - `name` — имя переменной (можете назвать как угодно)
  - `string` — тип данных (строка текста)
  - `=` — оператор присваивания
  - `"TempMail"` — значение переменной

- `:=` — короткий способ создать переменную. Go сам поймёт, что `8080` — это число. Работает только внутри функций.

- `bool` — логический тип, может быть `true` (истина) или `false` (ложь).

- `//` — начало комментария. Всё после `//` до конца строки игнорируется программой.

**Основные типы данных в Go:**

| Тип | Описание | Пример |
|-----|----------|--------|
| `string` | Текст | `"Привет"` |
| `int` | Целое число | `42` |
| `float64` | Дробное число | `3.14` |
| `bool` | Логическое значение | `true`, `false` |

---

## 5. Условные операторы

**Что это:**  
Условные операторы позволяют выполнять разный код в зависимости от условия.

**Пример:**
```go
package main

import "fmt"

func main() {
    age := 25
    
    if age >= 18 {
        fmt.Println("Вы совершеннолетний")
    } else {
        fmt.Println("Вы несовершеннолетний")
    }
}
```

**Разбор:**

- `if age >= 18` — если `age` больше или равно 18
  - `>=` — оператор "больше или равно"
  - Другие операторы сравнения: `==` (равно), `!=` (не равно), `>` (больше), `<` (меньше), `<=` (меньше или равно)

- `else` — иначе (если условие не выполнилось)

**Несколько условий:**
```go
package main

import "fmt"

func main() {
    status := "active"
    
    if status == "active" {
        fmt.Println("Ящик активен")
    } else if status == "expired" {
        fmt.Println("Ящик истёк")
    } else {
        fmt.Println("Неизвестный статус")
    }
}
```

- `else if` — иначе если (проверяем следующее условие)
- `==` — оператор сравнения "равно" (не путать с `=`, который присваивает значение)

---

## 6. Циклы

**Что это:**  
Циклы позволяют выполнять код несколько раз подряд.

**В Go есть только один цикл — `for`:**
```go
package main

import "fmt"

func main() {
    // Цикл с счётчиком
    for i := 0; i < 5; i++ {
        fmt.Println("Итерация:", i)
    }
}
```

**Разбор:**

- `for i := 0; i < 5; i++` — цикл состоит из трёх частей, разделённых `;`
  - `i := 0` — начальное значение счётчика (создаём переменную `i` равную 0)
  - `i < 5` — условие продолжения (пока `i` меньше 5, цикл работает)
  - `i++` — действие после каждой итерации (`i++` означает `i = i + 1`, то есть увеличиваем на 1)

**Результат:**
```
Итерация: 0
Итерация: 1
Итерация: 2
Итерация: 3
Итерация: 4
```

**Бесконечный цикл:**
```go
for {
    // Этот код будет выполняться вечно
    // Используйте break для выхода
}
```

- `break` — команда для выхода из цикла

---

## 7. Функции

**Что это:**  
Функция — это блок кода, который можно вызывать по имени. Помогает не повторять один и тот же код.

**Создаём функцию:**
```go
package main

import "fmt"

// Функция без параметров и без возвращаемого значения
func sayHello() {
    fmt.Println("Привет!")
}

// Функция с параметрами
func greet(name string) {
    fmt.Println("Привет,", name)
}

// Функция с возвращаемым значением
func add(a int, b int) int {
    return a + b
}

func main() {
    sayHello()           // Вызываем функцию
    greet("Олег")        // Передаём параметр
    
    result := add(5, 3)  // Получаем результат
    fmt.Println("5 + 3 =", result)
}
```

**Разбор:**

- `func sayHello()` — объявляем функцию с именем `sayHello`, без параметров

- `func greet(name string)` — функция принимает один параметр `name` типа `string`

- `func add(a int, b int) int` — функция принимает два параметра типа `int` и возвращает `int`
  - `int` после скобок — тип возвращаемого значения
  - `return a + b` — возвращаем результат сложения

**Результат:**
```
Привет!
Привет, Олег
5 + 3 = 8
```

---

## 8. Структуры (struct)

**Что это:**  
Структура — это способ объединить несколько связанных данных в один тип. Похоже на класс в других языках.

**Создаём структуру:**
```go
package main

import "fmt"

// Объявляем структуру Mailbox (почтовый ящик)
type Mailbox struct {
    ID      string
    Address string
    IsActive bool
}

func main() {
    // Создаём экземпляр структуры
    mailbox := Mailbox{
        ID:       "abc123",
        Address:  "abc123@tempmail.dev",
        IsActive: true,
    }
    
    // Обращаемся к полям через точку
    fmt.Println("ID:", mailbox.ID)
    fmt.Println("Адрес:", mailbox.Address)
    fmt.Println("Активен:", mailbox.IsActive)
    
    // Изменяем поле
    mailbox.IsActive = false
    fmt.Println("Теперь активен:", mailbox.IsActive)
}
```

**Разбор:**

- `type Mailbox struct` — создаём новый тип данных с именем `Mailbox`
  - `type` — ключевое слово для создания нового типа
  - `struct` — указываем, что это структура

- `ID string` — поле `ID` типа `string`

- `mailbox := Mailbox{...}` — создаём экземпляр (конкретный объект) структуры

- `mailbox.Address` — обращаемся к полю `Address` через точку

**Почему это полезно:**  
Вместо хранения данных в отдельных переменных, мы группируем связанные данные вместе. Это делает код понятнее и безопаснее.

---

## 9. Срезы (slices)

**Что это:**  
Срез — это динамический список элементов одного типа. Похоже на массив, но размер может меняться.

**Работа со срезами:**
```go
package main

import "fmt"

func main() {
    // Создаём пустой срез строк
    var emails []string
    
    // Добавляем элементы с помощью append
    emails = append(emails, "test1@mail.com")
    emails = append(emails, "test2@mail.com")
    emails = append(emails, "test3@mail.com")
    
    fmt.Println("Все письма:", emails)
    fmt.Println("Количество:", len(emails))
    fmt.Println("Первое письмо:", emails[0])
    
    // Перебираем все элементы
    for index, email := range emails {
        fmt.Printf("%d: %s\n", index, email)
    }
}
```

**Разбор:**

- `[]string` — срез строк (квадратные скобки без числа означают срез)

- `append(emails, "...")` — добавляет элемент в конец среза и возвращает новый срез

- `len(emails)` — возвращает количество элементов

- `emails[0]` — получаем элемент по индексу (нумерация с 0)

- `for index, email := range emails` — перебираем срез
  - `range` — ключевое слово для перебора
  - `index` — номер элемента (0, 1, 2...)
  - `email` — сам элемент

- `fmt.Printf` — форматированный вывод
  - `%d` — место для числа
  - `%s` — место для строки
  - `\n` — переход на новую строку

---

## 10. Карты (maps)

**Что это:**  
Карта — это структура данных "ключ-значение". Позволяет быстро находить значение по ключу.

**Работа с картами:**
```go
package main

import "fmt"

func main() {
    // Создаём карту: ключ string, значение int
    messageCount := make(map[string]int)
    
    // Добавляем значения
    messageCount["inbox"] = 10
    messageCount["spam"] = 3
    messageCount["sent"] = 5
    
    // Получаем значение по ключу
    fmt.Println("Входящих:", messageCount["inbox"])
    
    // Проверяем, есть ли ключ
    count, exists := messageCount["drafts"]
    if exists {
        fmt.Println("Черновиков:", count)
    } else {
        fmt.Println("Черновиков нет")
    }
    
    // Удаляем элемент
    delete(messageCount, "spam")
    
    // Перебираем карту
    for key, value := range messageCount {
        fmt.Printf("%s: %d\n", key, value)
    }
}
```

**Разбор:**

- `make(map[string]int)` — создаём карту
  - `make` — встроенная функция для создания карт, срезов и каналов
  - `map[string]int` — карта с ключами типа `string` и значениями типа `int`

- `messageCount["inbox"] = 10` — добавляем или изменяем значение

- `count, exists := messageCount["drafts"]` — получаем значение и флаг существования
  - `exists` будет `true`, если ключ есть, и `false`, если нет

- `delete(messageCount, "spam")` — удаляем элемент по ключу

---

## Что мы узнали

- Как установить Go и создать проект
- Основные типы данных: `string`, `int`, `bool`
- Как создавать переменные (полное и короткое объявление)
- Условные операторы `if`, `else`, `else if`
- Цикл `for` и его варианты
- Функции с параметрами и возвращаемыми значениями
- Структуры для группировки данных
- Срезы (динамические списки)
- Карты (ключ-значение)

---

[Следующая глава: Структура проекта и конфигурация](./02-project-structure.md)

[Вернуться к оглавлению](./README.md)

